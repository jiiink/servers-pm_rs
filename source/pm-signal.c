/* This file handles signals, which are asynchronous events and are generally
 * a messy and unpleasant business.  Signals can be generated by the KILL
 * system call, or from the keyboard (SIGINT) or from the clock (SIGALRM).
 * In all cases control eventually passes to check_sig() to see which processes
 * can be signaled.  The actual signaling is done by sig_proc().
 *
 * The entry points into this file are:
 *   do_sigaction:	perform the SIGACTION system call
 *   do_sigpending:	perform the SIGPENDING system call
 *   do_sigprocmask:	perform the SIGPROCMASK system call
 *   do_sigreturn:	perform the SIGRETURN system call
 *   do_sigsuspend:	perform the SIGSUSPEND system call
 *   do_kill:		perform the KILL system call
 *   process_ksig:	process a signal an behalf of the kernel
 *   sig_proc:		interrupt or terminate a signaled process
 *   check_sig:		check which processes to signal with sig_proc()
 *   check_pending:	check if a pending signal can now be delivered
 *   restart_sigs: 	restart signal work after finishing a VFS call
 */

#include "pm.h"
#include <sys/stat.h>
#include <sys/ptrace.h>
#include <minix/callnr.h>
#include <minix/endpoint.h>
#include <minix/com.h>
#include <minix/vm.h>
#include <signal.h>
#include <sys/resource.h>
#include <assert.h>
#include "mproc.h"

static int unpause_process(struct mproc *rmp);
static int send_signal_to_process(struct mproc *rmp, int signo);
static void terminate_process_by_signal(struct mproc *rmp, int signo);
static int stop_process_in_kernel(struct mproc *rmp, int may_delay);
static void try_resume_process_in_kernel(struct mproc *rmp);

/*===========================================================================*
 *				do_sigaction				     *
 *===========================================================================*/
int do_sigaction(void)
{
  int r, sig_nr;
  struct sigaction svec;
  struct sigaction *svp;
  struct mproc *current_mp = mp;

  assert(!(current_mp->mp_flags & (PROC_STOPPED | VFS_CALL | UNPAUSED | EVENT_CALL)));

  sig_nr = m_in.m_lc_pm_sig.nr;
  if (sig_nr == SIGKILL || sig_nr == SIGSTOP) return(EINVAL); /* SIGKILL and SIGSTOP cannot be caught, blocked, or ignored */
  if (sig_nr < 1 || sig_nr >= _NSIG) return(EINVAL);

  svp = &current_mp->mp_sigact[sig_nr];
  if (m_in.m_lc_pm_sig.oact != 0) {
	r = sys_datacopy(PM_PROC_NR,(vir_bytes) svp, who_e,
		(vir_bytes)m_in.m_lc_pm_sig.oact, (phys_bytes) sizeof(svec));
	if (r != OK) return(r);
  }

  if (m_in.m_lc_pm_sig.act == 0) /* No new action to set, just get old action */
  	return(OK);

  /* Read in the sigaction structure from user space. */
  r = sys_datacopy(who_e, (vir_bytes)m_in.m_lc_pm_sig.act, PM_PROC_NR, (vir_bytes) &svec,
	  (phys_bytes) sizeof(svec));
  if (r != OK) return(r);

  if (svec.sa_handler == SIG_IGN) {
	sigaddset(&current_mp->mp_ignore, sig_nr);
	sigdelset(&current_mp->mp_sigpending, sig_nr);
	sigdelset(&current_mp->mp_ksigpending, sig_nr);
	sigdelset(&current_mp->mp_catch, sig_nr);
  } else if (svec.sa_handler == SIG_DFL) {
	sigdelset(&current_mp->mp_ignore, sig_nr);
	sigdelset(&current_mp->mp_catch, sig_nr);
  } else {
	sigdelset(&current_mp->mp_ignore, sig_nr);
	sigaddset(&current_mp->mp_catch, sig_nr);
  }
  current_mp->mp_sigact[sig_nr].sa_handler = svec.sa_handler;
  sigdelset(&svec.sa_mask, SIGKILL); /* SIGKILL and SIGSTOP can't be masked */
  sigdelset(&svec.sa_mask, SIGSTOP);
  current_mp->mp_sigact[sig_nr].sa_mask = svec.sa_mask;
  current_mp->mp_sigact[sig_nr].sa_flags = svec.sa_flags;
  current_mp->mp_sigreturn = m_in.m_lc_pm_sig.ret; /* Address of sigreturn trampoline */
  return(OK);
}

/*===========================================================================*
 *				do_sigpending                                *
 *===========================================================================*/
int do_sigpending(void)
{
  struct mproc *current_mp = mp;
  assert(!(current_mp->mp_flags & (PROC_STOPPED | VFS_CALL | UNPAUSED | EVENT_CALL)));

  current_mp->mp_reply.m_pm_lc_sigset.set = current_mp->mp_sigpending;
  return OK;
}

/*===========================================================================*
 *				do_sigprocmask                               *
 *===========================================================================*/
int do_sigprocmask(void)
{
/* Note that the library interface passes the actual mask in sigmask_set,
 * not a pointer to the mask, in order to save a copy.  Similarly,
 * the old mask is placed in the return message which the library
 * interface copies (if requested) to the user specified address.
 *
 * The library interface must set SIG_INQUIRE if the 'act' argument
 * is NULL.
 *
 * KILL and STOP can't be masked.
 */
  sigset_t new_set;
  int i;
  struct mproc *current_mp = mp;

  assert(!(current_mp->mp_flags & (PROC_STOPPED | VFS_CALL | UNPAUSED | EVENT_CALL)));

  new_set = m_in.m_lc_pm_sigset.set;
  current_mp->mp_reply.m_pm_lc_sigset.set = current_mp->mp_sigmask; /* Return old mask */

  switch (m_in.m_lc_pm_sigset.how) {
      case SIG_BLOCK:
	/* Add signals to the block mask. SIGKILL and SIGSTOP cannot be blocked. */
	sigdelset(&new_set, SIGKILL);
	sigdelset(&new_set, SIGSTOP);
	for (i = 1; i < _NSIG; i++) {
		if (sigismember(&new_set, i))
			sigaddset(&current_mp->mp_sigmask, i);
	}
	break;

      case SIG_UNBLOCK:
	/* Remove signals from the block mask. */
	for (i = 1; i < _NSIG; i++) {
		if (sigismember(&new_set, i))
			sigdelset(&current_mp->mp_sigmask, i);
	}
	check_pending(current_mp); /* Check for newly unblocked signals */
	break;

      case SIG_SETMASK:
	/* Set the block mask to a new value. SIGKILL and SIGSTOP cannot be blocked. */
	sigdelset(&new_set, SIGKILL);
	sigdelset(&new_set, SIGSTOP);
	current_mp->mp_sigmask = new_set;
	check_pending(current_mp); /* Check for newly unblocked signals */
	break;

      case SIG_INQUIRE:
	/* No change to mask, just return current mask (done above) */
	break;

      default:
	return(EINVAL);
  }
  return OK;
}

/*===========================================================================*
 *				do_sigsuspend                                *
 *===========================================================================*/
int do_sigsuspend(void)
{
  struct mproc *current_mp = mp;
  assert(!(current_mp->mp_flags & (PROC_STOPPED | VFS_CALL | UNPAUSED | EVENT_CALL)));

  current_mp->mp_sigmask2 = current_mp->mp_sigmask;	/* save the old mask */
  current_mp->mp_sigmask = m_in.m_lc_pm_sigset.set; /* Set new mask */
  sigdelset(&current_mp->mp_sigmask, SIGKILL); /* SIGKILL and SIGSTOP can't be masked */
  sigdelset(&current_mp->mp_sigmask, SIGSTOP);
  current_mp->mp_flags |= SIGSUSPENDED; /* Mark process as suspended */
  check_pending(current_mp); /* Check if any pending signals can now be delivered */
  return(SUSPEND); /* The process will block until a signal is delivered */
}

/*===========================================================================*
 *				do_sigreturn				     *
 *===========================================================================*/
int do_sigreturn(void)
{
/* A user signal handler is done. Restore context and check for
 * pending unblocked signals.
 */
  int r;
  struct mproc *current_mp = mp;

  assert(!(current_mp->mp_flags & (PROC_STOPPED | VFS_CALL | UNPAUSED | EVENT_CALL)));

  current_mp->mp_sigmask = m_in.m_lc_pm_sigset.set; /* Restore signal mask */
  sigdelset(&current_mp->mp_sigmask, SIGKILL); /* SIGKILL and SIGSTOP can't be masked */
  sigdelset(&current_mp->mp_sigmask, SIGSTOP);

  r = sys_sigreturn(who_e, (struct sigmsg *)m_in.m_lc_pm_sigset.ctx); /* Restore CPU context */
  check_pending(current_mp); /* Check for newly unblocked signals */
  return(r);
}

/*===========================================================================*
 *				do_kill					     *
 *===========================================================================*/
int do_kill(void)
{
/* Perform the kill(pid, signo) system call. */
  return check_sig(m_in.m_lc_pm_sig.pid, m_in.m_lc_pm_sig.nr, FALSE /* ksig */);
}

/*===========================================================================*
 *			      do_srv_kill				     *
 *===========================================================================*/
int do_srv_kill(void)
{
/* Perform the srv_kill(pid, signo) system call. */

  /* Only RS is allowed to use srv_kill. */
  if (mp->mp_endpoint != RS_PROC_NR)
	return EPERM;

  /* Pretend the signal comes from the kernel when RS wants to deliver a signal
   * to a system process. RS sends a SIGKILL when it wants to perform cleanup.
   * In that case, ksig == TRUE forces PM to exit the process immediately.
   */
  return check_sig(m_in.m_rs_pm_srv_kill.pid, m_in.m_rs_pm_srv_kill.nr,
	  TRUE /* ksig */);
}

/*===========================================================================*
 *				stop_process_in_kernel				     *
 *===========================================================================*/
static int stop_process_in_kernel(struct mproc *rmp, int may_delay)
{
/* Try to stop the given process in the kernel. If successful, mark the process
 * as stopped and return TRUE.  If the process is still busy sending a message,
 * the behavior depends on the 'may_delay' parameter. If set, the process will
 * be marked as having a delay call pending, and the function returns FALSE. If
 * not set, the caller already knows that the process has no delay call, and PM
 * will panic.
 */
  int r;

  assert(!(rmp->mp_flags & (PROC_STOPPED | DELAY_CALL | UNPAUSED)));

  r = sys_delay_stop(rmp->mp_endpoint);

  /* If the process is still busy sending a message, the kernel will give us
   * EBUSY now and send a SIGSNDELAY to the process as soon as sending is done.
   */
  switch (r) {
  case OK:
	rmp->mp_flags |= PROC_STOPPED;
	return TRUE;

  case EBUSY:
	if (!may_delay)
		panic("stop_process_in_kernel: unexpected delay call for endpoint %d", rmp->mp_endpoint);
	rmp->mp_flags |= DELAY_CALL;
	return FALSE;

  default:
	panic("sys_delay_stop failed for endpoint %d: %d", rmp->mp_endpoint, r);
  }
}

/*===========================================================================*
 *				try_resume_process_in_kernel				     *
 *===========================================================================*/
static void try_resume_process_in_kernel(struct mproc *rmp)
{
/* Resume the given process if possible. */
  int r;

  assert(rmp->mp_flags & PROC_STOPPED);

  /* If the process is blocked on a VFS call or a process event notification,
   * do not resume it now.  Most likely it will be unpausing, in which case the
   * process must remain stopped.  Otherwise, it will still be resumed once the
   * VFS or event call is replied to.  If the process has died, do not resume
   * it either.
   */
  if (rmp->mp_flags & (VFS_CALL | EVENT_CALL | EXITING))
	return;

  if ((r = sys_resume(rmp->mp_endpoint)) != OK)
	panic("sys_resume failed for endpoint %d: %d", rmp->mp_endpoint, r);

  /* Also unset the unpaused flag. We can safely assume that a stopped process
   * need only be unpaused once, but once it is resumed, all bets are off.
   */
  rmp->mp_flags &= ~(PROC_STOPPED | UNPAUSED);
}

/*===========================================================================*
 *				process_ksig				     *
 *===========================================================================*/
int process_ksig(endpoint_t proc_nr_e, int signo)
{
  register struct mproc *rmp_target;
  int proc_nr;
  pid_t proc_id, id_for_check_sig;
  struct mproc *original_mp = mp; /* Save global 'mp' state */
  int original_who_p = who_p;
  int original_who_e = who_e;
  int original_call_nr = call_nr;

  if(pm_isokendpt(proc_nr_e, &proc_nr) != OK) {
	printf("PM: process_ksig: invalid endpoint %d, signal %d\n", proc_nr_e, signo);
	return EDEADEPT; /* process is gone. */
  }
  rmp_target = &mproc[proc_nr];
  if ((rmp_target->mp_flags & (IN_USE | EXITING)) != IN_USE) {
	/*printf("PM: process_ksig: endpoint %d (proc %d) not in use or exiting, signal %d\n", proc_nr_e, proc_nr, signo);*/
	return EDEADEPT; /* process is gone. */
  }
  proc_id = rmp_target->mp_pid;

  /* Set global context to PM itself for `check_sig` for privilege checks.
   * `check_sig` assumes `mp` refers to the sender of the signal.
   */
  mp = &mproc[PM_PROC_NR];			/* pretend signals are from PM */
  who_p = PM_PROC_NR;
  who_e = mproc[PM_PROC_NR].mp_endpoint;
  call_nr = PM_KILL; /* Placeholder, actual call_nr might not be relevant for check_sig in this context */
  mp->mp_procgrp = rmp_target->mp_procgrp;	/* set process group right for broadcast signals */


  /* For SIGVTALRM and SIGPROF, see if we need to restart a
   * virtual timer. For SIGINT, SIGINFO, SIGWINCH and SIGQUIT, use proc_id 0
   * to indicate a broadcast to the recipient's process group.  For
   * SIGKILL, use proc_id -1 to indicate a systemwide broadcast.
   */
  switch (signo) {
      case SIGINT:
      case SIGQUIT:
      case SIGWINCH:
      case SIGINFO:
  	id_for_check_sig = 0; break;	/* broadcast to process group */
      case SIGVTALRM:
      case SIGPROF:
      	check_vtimer(proc_nr, signo); /* Handle virtual timer restart */
      	/* fall-through */
      default:
  	id_for_check_sig = proc_id;
  	break;
  }
  check_sig(id_for_check_sig, signo, TRUE /* ksig */);

  /* Restore global 'mp' state */
  mp = original_mp;
  who_p = original_who_p;
  who_e = original_who_e;
  call_nr = original_call_nr;
  /* mp->mp_procgrp is restored if `mp` is restored to `original_mp` */


  /* If SIGSNDELAY is set, an earlier sys_stop() failed because the process was
   * still sending, and the kernel hereby tells us that the process is now done
   * with that. We can now try to resume what we planned to do in the first
   * place: set up a signal handler. However, the process's message may have
   * been a call to PM, in which case the process may have changed any of its
   * signal settings. The process may also have forked, exited etcetera.
   */
  if (signo == SIGSNDELAY && (rmp_target->mp_flags & DELAY_CALL)) {
	/* When getting SIGSNDELAY, the process is stopped at least until the
	 * receipt of the SIGSNDELAY signal is acknowledged to the kernel. The
	 * process is not stopped on PROC_STOP in the kernel. However, now that
	 * there is no longer a delay call, stop_process_in_kernel() is guaranteed to
	 * succeed immediately.
	 */
	rmp_target->mp_flags &= ~DELAY_CALL;

	assert(!(rmp_target->mp_flags & PROC_STOPPED));

	/* If the delay call was to PM, it may have resulted in a VFS call. In
	 * that case, we must wait with further signal processing until VFS has
	 * replied. Stop the process.
	 */
	if (rmp_target->mp_flags & (VFS_CALL | EVENT_CALL)) {
		stop_process_in_kernel(rmp_target, FALSE /*may_delay*/);
		return OK;
	}

	/* Process as many normal signals as possible. */
	check_pending(rmp_target);

	assert(!(rmp_target->mp_flags & DELAY_CALL));
  }

  /* See if the process is still alive. */
  if ((mproc[proc_nr].mp_flags & (IN_USE | EXITING)) == IN_USE)  {
      return OK; /* signal has been delivered */
  }
  else {
      return EDEADEPT; /* process is gone */
  }
}

/*===========================================================================*
 *				sig_proc				     *
 *===========================================================================*/
void
sig_proc(
	register struct mproc *rmp_target,	/* pointer to the process to be signaled */
	int signo,			/* signal to send to process (1 to _NSIG-1) */
	int trace,			/* pass signal to tracer first? */
	int ksig			/* non-zero means signal comes from kernel  */
)
{
/* Send a signal to a process.  Check to see if the signal is to be caught,
 * ignored, tranformed into a message (for system processes) or blocked.
 *  - If the signal is to be transformed into a message, request the KERNEL to
 * send the target process a system notification with the pending signal as an
 * argument.
 *  - If the signal is to be caught, request the KERNEL to push a sigcontext
 * structure and a sigframe structure onto the catcher's stack.  Also, KERNEL
 * will reset the program counter and stack pointer, so that when the process
 * next runs, it will be executing the signal handler. When the signal handler
 * returns,  sigreturn(2) will be called.  Then KERNEL will restore the signal
 * context from the sigcontext structure.
 * If there is insufficient stack space, kill the process.
 */
  int slot, badignore;

  slot = (int) (rmp_target - mproc);
  if ((rmp_target->mp_flags & (IN_USE | EXITING)) != IN_USE) {
	printf("PM: signal %d sent to already exiting process %d (endpoint %d)\n", signo, slot, rmp_target->mp_endpoint);
    return;
  }

  if (trace == TRUE && rmp_target->mp_tracer != NO_TRACER && signo != SIGKILL) {
	/* Signal should be passed to the debugger first.
	 * This happens before any checks on block/ignore masks; otherwise,
	 * the process itself could block/ignore debugger signals.
	 */
	sigaddset(&rmp_target->mp_sigtrace, signo);

	if (!(rmp_target->mp_flags & TRACE_STOPPED))
		trace_stop(rmp_target, signo);	/* a signal causes it to stop */
	return;
  }

  if (rmp_target->mp_flags & (VFS_CALL | EVENT_CALL)) {
	sigaddset(&rmp_target->mp_sigpending, signo);
	if(ksig)
		sigaddset(&rmp_target->mp_ksigpending, signo);

	/* Process the signal once VFS and process event subscribers reply.
	 * Stop the process in the meantime, so that it cannot make another
	 * call after the VFS reply comes in but before we look at its signals
	 * again. Since we always stop the process to deliver signals during a
	 * VFS or event call, the PROC_STOPPED flag doubles as an indicator in
	 * restart_sigs() that signals must be rechecked after a reply arrives.
	 */
	if (!(rmp_target->mp_flags & (PROC_STOPPED | DELAY_CALL))) {
		/* If a VFS call is ongoing and the process is not yet stopped,
		 * the process must have made a call to PM. Therefore, there
		 * can be no delay calls in this case.
		 */
		stop_process_in_kernel(rmp_target, FALSE /*may_delay*/);
	}
	return;
  }

  /* Handle system signals for system processes first. */
  if(rmp_target->mp_flags & PRIV_PROC) {
   	/* Always skip signals for PM (only necessary when broadcasting). */
   	if(rmp_target->mp_endpoint == PM_PROC_NR) {
 		return;
   	}

   	/* System signals have always to go through the kernel first to let it
   	 * pick the right signal manager. If PM is the assigned signal manager,
   	 * the signal will come back and will actually be processed.
   	 */
   	if(!ksig) {
 		sys_kill(rmp_target->mp_endpoint, signo);
 		return;
   	}

  	/* Print stacktrace if necessary. */
  	if(SIGS_IS_STACKTRACE(signo)) {
		sys_diagctl_stacktrace(rmp_target->mp_endpoint);
  	}

  	if(!SIGS_IS_TERMINATION(signo)) {
		/* Translate every non-termination sys signal into a message. */
		message m;
		memset(&m, 0, sizeof(m));
		m.m_type = SIGS_SIGNAL_RECEIVED;
		m.m_pm_lsys_sigs_signal.num = signo;
		asynsend3(rmp_target->mp_endpoint, &m, AMF_NOREPLY);
	}
	else {
		/* Exit the process in case of termination system signal. */
		terminate_process_by_signal(rmp_target, signo);
	}
	return;
  }

  /* Handle user processes now. See if the signal cannot be safely ignored. */
  badignore = ksig && sigismember(&noign_sset, signo) && (
	  sigismember(&rmp_target->mp_ignore, signo) ||
	  sigismember(&rmp_target->mp_sigmask, signo));

  if (!badignore && sigismember(&rmp_target->mp_ignore, signo)) {
	/* Signal should be ignored. */
	return;
  }
  if (!badignore && sigismember(&rmp_target->mp_sigmask, signo)) {
	/* Signal should be blocked. */
	sigaddset(&rmp_target->mp_sigpending, signo);
	if(ksig)
		sigaddset(&rmp_target->mp_ksigpending, signo);
	return;
  }

  if ((rmp_target->mp_flags & TRACE_STOPPED) && signo != SIGKILL) {
	/* If the process is stopped for a debugger, do not deliver any signals
	 * (except SIGKILL) in order not to confuse the debugger. The signals
	 * will be delivered using the check_pending() calls in do_trace().
	 */
	sigaddset(&rmp_target->mp_sigpending, signo);
	if(ksig)
		sigaddset(&rmp_target->mp_ksigpending, signo);
	return;
  }
  if (!badignore && sigismember(&rmp_target->mp_catch, signo)) {
	/* Signal is caught. First interrupt the process's current call, if
	 * applicable. This may involve a roundtrip to VFS, in which case we'll
	 * have to check back later.
	 */
	if (!unpause_process(rmp_target)) {
		/* not yet unpaused; continue later */
		sigaddset(&rmp_target->mp_sigpending, signo);
		if(ksig)
			sigaddset(&rmp_target->mp_ksigpending, signo);
		return;
	}

	/* Then send the actual signal to the process, by setting up a signal
	 * handler.
	 */
	if (send_signal_to_process(rmp_target, signo))
		return;

	/* We were unable to spawn a signal handler. Kill the process. */
	printf("PM: %d can't catch signal %d - killing\n",
		rmp_target->mp_pid, signo);
  }
  else if (!badignore && sigismember(&ign_sset, signo)) {
	/* Signal defaults to being ignored. */
	return;
  }

  /* Terminate process */
  terminate_process_by_signal(rmp_target, signo);
}

/*===========================================================================*
 *				terminate_process_by_signal				     *
 *===========================================================================*/
static void
terminate_process_by_signal(
	struct mproc *rmp,		/* process that must exit */
	int signo			/* signal that caused termination */
)
{
  rmp->mp_sigstatus = (char) signo;
  if (sigismember(&core_sset, signo)) {
	if(!(rmp->mp_flags & PRIV_PROC)) {
		printf("PM: coredump signal %d for %d / %s\n", signo,
			rmp->mp_pid, rmp->mp_name);
		sys_diagctl_stacktrace(rmp->mp_endpoint);
	}
	exit_proc(rmp, 0, TRUE /*dump_core*/);
  }
  else {
  	exit_proc(rmp, 0, FALSE /*dump_core*/);
  }
}

/*===========================================================================*
 *				check_sig				     *
 *===========================================================================*/
int check_sig(pid_t proc_id, int signo, int ksig)
{
/* Check to see if it is possible to send a signal. The signal may have to be
 * sent to a group of processes. This routine is invoked by the KILL system
 * call, and also when the kernel catches a DEL or other signal.
 * The global variable 'mp' refers to the process making the `kill` call,
 * or PM itself if ksig is TRUE (set in process_ksig).
 */

  register struct mproc *rmp_target;
  int count;			/* count # of signals sent */
  int error_code;

  if (signo < 0 || signo >= _NSIG) return(EINVAL);

  /* Return EINVAL for attempts to send SIGKILL to INIT alone. */
  if (proc_id == INIT_PID && signo == SIGKILL) return(EINVAL);

  /* Signal RS first when broadcasting SIGTERM. */
  if (proc_id == -1 && signo == SIGTERM) {
      /* This is an asynchronous system call to RS, not handled by PM's `check_sig` logic */
      sys_kill(RS_PROC_NR, signo);
  }

  /* Search the proc table for processes to signal. Start from the end of the
   * table to analyze core system processes at the end when broadcasting.
   * (See forkexit.c about pid magic.)
   */
  count = 0;
  error_code = ESRCH; /* Default error if no process found */
  for (rmp_target = &mproc[NR_PROCS-1]; rmp_target >= &mproc[0]; rmp_target--) {
	if (!(rmp_target->mp_flags & IN_USE)) continue;

	/* Check for selection based on proc_id. */
	if (proc_id > 0 && proc_id != rmp_target->mp_pid) continue;
	if (proc_id == 0 && mp->mp_procgrp != rmp_target->mp_procgrp) continue; /* Broadcast to group of caller */
	if (proc_id == -1 && rmp_target->mp_pid <= INIT_PID) continue; /* Broadcast to all except system processes */
	if (proc_id < -1 && rmp_target->mp_procgrp != -proc_id) continue; /* Broadcast to specific process group */

	/* Do not kill servers and drivers when broadcasting SIGKILL to user processes. */
	if (proc_id == -1 && signo == SIGKILL && (rmp_target->mp_flags & PRIV_PROC)) continue;

	/* Skip VM entirely as it might lead to a deadlock with its signal
	 * manager if the manager page faults at the same time.
	 */
	if (rmp_target->mp_endpoint == VM_PROC_NR) continue;

	/* Disallow lethal signals sent by user processes to privileged system processes. */
	if (!ksig && SIGS_IS_LETHAL(signo) && (rmp_target->mp_flags & PRIV_PROC)) {
	    error_code = EPERM; /* Set EPERM but continue searching for other targets */
	    continue;
	}

	/* Check for permission. The 'mp' global indicates the sender context. */
	if (mp->mp_effuid != SUPER_USER &&
	    mp->mp_realuid != rmp_target->mp_realuid &&
	    mp->mp_effuid != rmp_target->mp_realuid &&
	    mp->mp_realuid != rmp_target->mp_effuid &&
	    mp->mp_effuid != rmp_target->mp_effuid) {
		error_code = EPERM; /* Set EPERM but continue searching for other targets */
		continue;
	}

	count++; /* This process qualifies and sender has permission */
	if (signo == 0 || (rmp_target->mp_flags & EXITING)) continue; /* If signo is 0 (check permission only) or process is already exiting */

	/* 'sig_proc' will handle the disposition of the signal. The
	 * signal may be caught, blocked, ignored, or cause process
	 * termination, possibly with core dump.
	 */
	sig_proc(rmp_target, signo, TRUE /*trace*/, ksig);

	if (proc_id > 0) break;	/* only one process being signaled */
  }

  /* If the calling process has killed itself, don't reply. */
  if ((mp->mp_flags & (IN_USE | EXITING)) != IN_USE) return(SUSPEND);
  return(count > 0 ? OK : error_code);
}

/*===========================================================================*
 *				check_pending				     *
 *===========================================================================*/
void
check_pending(register struct mproc *rmp)
{
  /* Check to see if any pending signals have been unblocked. Deliver as many
   * of them as we can, until we have to wait for a reply from VFS first.
   *
   * There are several places in this file where the signal mask is
   * changed. At each such place, check_pending() should be called to
   * check for newly unblocked signals.
   */
  int i;
  int ksig;

  for (i = 1; i < _NSIG; i++) {
	if (sigismember(&rmp->mp_sigpending, i) &&
		!sigismember(&rmp->mp_sigmask, i)) {
		ksig = sigismember(&rmp->mp_ksigpending, i);
		sigdelset(&rmp->mp_sigpending, i);
		sigdelset(&rmp->mp_ksigpending, i);
		sig_proc(rmp, i, FALSE /*trace*/, ksig);

		if (rmp->mp_flags & (VFS_CALL | EVENT_CALL)) {
			/* Signals must be rechecked upon return from the new
			 * VFS call, unless the process was killed. In both
			 * cases, the process is stopped.
			 */
			assert(rmp->mp_flags & PROC_STOPPED);
			break; /* Stop processing pending signals for this process for now */
		}
	}
  }
}

/*===========================================================================*
 *				restart_sigs				     *
 *===========================================================================*/
void
restart_sigs(struct mproc *rmp)
{
/* VFS has replied to a request from us; do signal-related work.
 */

  if (rmp->mp_flags & (VFS_CALL | EVENT_CALL | EXITING)) return;

  if (rmp->mp_flags & TRACE_EXIT) {
	/* Tracer requested exit with specific exit value */
	exit_proc(rmp, rmp->mp_exitstatus, FALSE /*dump_core*/);
  }
  else if (rmp->mp_flags & PROC_STOPPED) {
	/* If a signal arrives while we are performing a VFS call, the process
	 * will always be stopped immediately. Thus, if the process is stopped
	 * once the reply from VFS arrives, we might have to check signals.
	 */
	assert(!(rmp->mp_flags & DELAY_CALL));

	/* We saved signal(s) for after finishing a VFS call. Deal with this.
	 * PROC_STOPPED remains set to indicate the process is still stopped.
	 */
	check_pending(rmp);

	/* Resume the process now, unless there is a reason not to. */
	try_resume_process_in_kernel(rmp);
  }
}

/*===========================================================================*
 *				unpause_process					     *
 *===========================================================================*/
static int
unpause_process(
	struct mproc *rmp		/* which process */
)
{
/* A signal is to be sent to a process. If that process is hanging on a
 * system call, the system call must be terminated with EINTR. First check if
 * the process is hanging on an PM call. If not, tell VFS, so it can check for
 * interruptible calls such as READs and WRITEs from pipes, ttys and the like.
 */
  message m;

  assert(!(rmp->mp_flags & (VFS_CALL | EVENT_CALL)));

  /* If the UNPAUSED flag is set, VFS replied to an earlier unpause request. */
  if (rmp->mp_flags & UNPAUSED) {
	assert((rmp->mp_flags & (DELAY_CALL | PROC_STOPPED)) == PROC_STOPPED);
	return TRUE;
  }

  /* If the process is already stopping (waiting for SIGSNDELAY), don't do anything now. */
  if (rmp->mp_flags & DELAY_CALL)
	return FALSE;

  /* Check to see if process is hanging on a WAIT or SIGSUSPEND call within PM. */
  if (rmp->mp_flags & (WAITING | SIGSUSPENDED)) {
	/* Stop the process from running. Do not interrupt the actual call yet.
	 * send_signal_to_process() will interrupt the call and resume the process afterward.
	 * No delay calls here: we know for a fact that the process called us.
	 */
	stop_process_in_kernel(rmp, FALSE /*may_delay*/);
	return TRUE;
  }

  /* Not paused in PM. Let VFS, and after that any matching process event
   * subscribers, try to unpause the process. The process needs to be stopped
   * for this. If it is not already stopped, try to stop it now. If that does
   * not succeed immediately, postpone signal delivery.
   */
  if (!(rmp->mp_flags & PROC_STOPPED) && !stop_process_in_kernel(rmp, TRUE /*may_delay*/))
	return FALSE;

  memset(&m, 0, sizeof(m));
  m.m_type = VFS_PM_UNPAUSE;
  m.VFS_PM_ENDPT = rmp->mp_endpoint;

  tell_vfs(rmp, &m);

  return FALSE;
}

/*===========================================================================*
 *				send_signal_to_process				     *
 *===========================================================================*/
static int
send_signal_to_process(
	struct mproc *rmp,		/* what process to spawn a signal handler in */
	int signo			/* signal to send to process (1 to _NSIG-1) */
)
{
/* The process is supposed to catch this signal. Spawn a signal handler.
 * Return TRUE if this succeeded, FALSE otherwise.
 */
  struct sigmsg sigmsg;
  int i, r, sigflags, slot;

  assert(rmp->mp_flags & PROC_STOPPED);

  sigflags = rmp->mp_sigact[signo].sa_flags;
  slot = (int) (rmp - mproc);

  /* Set up the signal message to be passed to the kernel. */
  if (rmp->mp_flags & SIGSUSPENDED)
	sigmsg.sm_mask = rmp->mp_sigmask2; /* Restore previous mask if from sigsuspend */
  else
	sigmsg.sm_mask = rmp->mp_sigmask;
  sigmsg.sm_signo = signo;
  sigmsg.sm_sighandler = (vir_bytes) rmp->mp_sigact[signo].sa_handler;
  sigmsg.sm_sigreturn = rmp->mp_sigreturn;

  /* Update the process's signal mask for the duration of the handler. */
  for (i = 1; i < _NSIG; i++) {
	if (sigismember(&rmp->mp_sigact[signo].sa_mask, i))
		sigaddset(&rmp->mp_sigmask, i);
  }

  /* Apply SA_NODEFER and SA_RESETHAND flags. */
  if (sigflags & SA_NODEFER)
	sigdelset(&rmp->mp_sigmask, signo); /* Don't block current signal */
  else
	sigaddset(&rmp->mp_sigmask, signo); /* Block current signal */

  if (sigflags & SA_RESETHAND) {
	sigdelset(&rmp->mp_catch, signo);
	rmp->mp_sigact[signo].sa_handler = SIG_DFL;
  }
  sigdelset(&rmp->mp_sigpending, signo); /* Clear pending status for this signal */
  sigdelset(&rmp->mp_ksigpending, signo);

  /* Ask the kernel to deliver the signal. */
  r = sys_sigsend(rmp->mp_endpoint, &sigmsg);
  /* sys_sigsend can fail legitimately with EFAULT or ENOMEM if the process
   * memory can't accommodate the signal handler. The target process will be
   * killed in that case, so do not bother interrupting or resuming it.
   */
  if(r == EFAULT || r == ENOMEM) {
	return(FALSE);
  }
  /* Other errors are unexpected pm/kernel discrepancies. */
  if (r != OK) {
	panic("sys_sigsend failed for endpoint %d: %d", rmp->mp_endpoint, r);
  }

  /* Was the process suspended in PM (WAITING or SIGSUSPENDED)? */
  if (rmp->mp_flags & (WAITING | SIGSUSPENDED)) {
	rmp->mp_flags &= ~(WAITING | SIGSUSPENDED);

	reply(slot, EINTR); /* Interrupt the blocking call */

	/* The process must just have been stopped by unpause_process(), which means
	 * that the UNPAUSED flag is not set.
	 */
	assert(!(rmp->mp_flags & UNPAUSED));

	try_resume_process_in_kernel(rmp);
	assert(!(rmp->mp_flags & PROC_STOPPED));
  } else {
	/* If the process was not suspended in PM, VFS must first have
	 * confirmed that it has tried to unsuspend any blocking call. Thus, we
	 * got here from restart_sigs() as part of handling PM_UNPAUSE_REPLY,
	 * and restart_sigs() will resume the process later.
	 */
	assert(rmp->mp_flags & UNPAUSED);
  }

  return(TRUE);
}